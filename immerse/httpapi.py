# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_httpapi.ipynb (unless otherwise specified).

__all__ = ['get_coreurl', 'add_items', 'get_items', 'cat', 'get_peers', 'find_dht_peer', 'find_value_provider',
           'get_dht_value', 'block_get', 'block_put', 'block_rm', 'block_stat']

# Cell
import requests
import json
from fastcore.all import *
import pandas as pd

# Cell
def get_coreurl(
    local:bool=True, # If local uses local node, else uses Infura.io gateway
):
    'Set the core url for convenience'
    if local:
        return f"http://127.0.0.1:5001/api/v0"
    else:
        return f"https://ipfs.infura.io:5001/api/v0"

# Cell
def add_items(
    coreurl:str, # Core URL to use
    filepath:str, # Path to the file/directory to be added to IPFS
    wrap_with_directory:str='false', # True if path is a directory
    recursive:str='false', # Add directory paths recursively
    chunker:str='size-262144', # Chunking algorithm, size-[bytes], rabin-[min]-[avg]-[max] or buzhash
    pin:str='true', # Pin this object when adding
    hash_:str='sha2-256', # Hash function to use. Implies CIDv1 if not sha2-256
    progress:str='true', # Stream progress data
    silent:str='false', # Write no output
    cid_version:int=0, # CID version
    **kwargs,
):
    "add file/directory to ipfs"

    params = {}
    params['wrap-with-directory'] = wrap_with_directory
    params['chunker'] = chunker
    params['pin'] = pin
    params['hash'] = hash_
    params['progress'] = progress
    params['silent'] = silent
    params['cid-version'] = cid_version
    params.update(kwargs)

    if recursive == 'false':
        files = {
            'file': open(filepath, 'rb'),
        }

    else:
        files = {
            str(fn.name) : open(str(fn), 'rb') for fn in Path(filepath).ls()
        }

    response = requests.post(f'{coreurl}/add',
                             params=params,
                             files=files)
    try:
        print("Added", filepath, "to IPFS - ","Response", response.status_code)
        return response, json.loads(response.text.strip().split('\n')[-1])

    except:
        print(response.status_code)
        return response, ""

# Cell

# doesnt save the file in the output folder given
def get_items(
    coreurl:str,
    cid:str, # The path to the IPFS object(s) to be outputted
    output:str='', # The path where the output should be stored
    **kwargs
):
    'Download IPFS objects'

    params = {}
    params['arg'] = cid
    params['output'] = output
    params.update(kwargs)

    response = requests.post(f'{coreurl}/get', params=params)

    return response


def cat(
    coreurl:str,
    cid:str, # The path to the IPFS object(s) to be outputted
    offset:int, # Byte offset to begin reading from
    length:int, # Maximum number of bytes to read
    **kwargs
):
    'Show IPFS object data'

    params = {}
    params['args'] = cid
    params['offset'] = offset
    params['length'] = length
    params.update(kwargs)

    return requests.post(f'{coreurl}/cat', params=params)

# Cell
def get_peers(
    coreurl,
    verbose='true', # Display all extra information
    streams='false', # Also list information about open streams for each peer
    latency='false', # Also list information about latency to each peer
    direction='false' # Also list information about the direction of connection
):
    'List peers with open connections.'

    params = {}
    params['verbose'] = verbose
    params['streams'] = streams
    params['latency'] = latency
    params['direction'] = direction

    return requests.post(f"{coreurl}/swarm/peers", params=params).json()

# Cell
def find_dht_peer(
    coreurl:str,
    key:str,  # The ID of the peer to search for
    verbose:str='true', #Print extra information
):
    'Find the multiaddresses associated with a Peer ID.'

    params = {}
    params['arg'] = key
    params['verbose'] = verbose

    return requests.post(f'{coreurl}/dht/findpeer', params=params).json()

def find_value_provider(
    coreurl:str,
    key:str,  # The key to find providers for
    verbose:str='true', #Print extra information
):
    'Find peers that can provide a specific value, given a key.'

    params = {}
    params['arg'] = key
    params['verbose'] = verbose

    return requests.post(f'{coreurl}/dht/findpeer', params=params)

def get_dht_value(
    coreurl:str,
    key:str,  # The key to find a value for
    verbose:str='true', #Print extra information
):
    'Given a key, query the routing system for its best value.'

    params = {}
    params['arg'] = key
    params['verbose'] = verbose

    return requests.post(f'{coreurl}/dht/get', params=params).json()

# Cell
def block_get(
    coreurl,
    arg:str, # The base58 multihash of an existing block to get

):
    'Get a raw IPFS block.'

    params = {}
    params['arg'] = arg

    return requests.post(f'{coreurl}/block/get', params=params)


def block_put(
    coreurl,
    filepath:str, # Path to file
    mhtype:str='sha2-256', # multihash hash function.
    mhlen:int=-1, # Multihash hash length
    pin:str='false', #  pin added blocks recursively
    **kwargs,
):
    'Store input as an IPFS block.'

    params = {}
    params['mhtype'] = mhtype
    params['mhlen'] = mhlen
    params['pin'] = pin
    params.update(kwargs)

    return requests.post(f'{coreurl}/block/put', params=params, files={'files':open(filepath, 'rb')})


def block_rm(
    coreurl,
    arg:str, # Bash58 encoded multihash of block(s) to remove
    force:str='false', # Ignore nonexistent blocks.
    quiet:str='false', # Write minimal output.
):
    'Remove IPFS block(s).'

    params = {}
    params['arg'] = arg
    params['force'] = force
    params['quiet'] = quiet

    return requests.post(f'{coreurl}/block/rm', params=params)


def block_stat(
    coreurl,
    arg:str, # Bash58 encoded multihash of block(s) to remove

):
    'Print information of a raw IPFS block.'

    params = {}
    params['arg'] = arg

    return requests.post(f'{coreurl}/block/stat', params=params)